## 흐름 제어 (Flow Control)

송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법이다. 

예를 들어, 송신측이 수신측보다 속도가 빠를 때 수신하는 쪽에서 처리할 수 있는 데이터(packet)의 양을 초과하면 이후의 데이터들은 손실되는 문제가 발생한다. 즉 데이터의 전송 속도가 데이터의 처리 속도보다 빠를 경우 데이터의 손실이 발생하고, 손실되면 송/수신 측 간의 불필요한 응답 메세지와 데이터의 전송이 빈번하게 발생한다. 이러한 위험과 비용을 방지하기 위해 **송신측의 데이터 전송량**을 **수신측에 따라** **조절하는 것**이 **흐름 제어**이다.

수신측이 데이터를 저장하는 곳을 큐라고 하기도 하고, TCP 버퍼라고 하기도 함. *

- **TCP 버퍼**
    
    송신 측은 버퍼에 TCP 세그먼트를 보관한 후 순차적으로 전송하고, 수신 측은 도착한 TCP 세그먼트를 애플리케이션이 읽을 때까지 버퍼에 보관한다.
    

### 흐름 제어 기법

- **Stop and Wait**
    
    송신측에서 매번 전송한 패킷에 대한 수신측의 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법이다.
    
    하지만 다음 패킷을 전송하는 데 시간이 걸리기 때문에 비효율적이다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4b052c7b-35e0-44e9-9454-0e95077dff78/Untitled.png)
    
- **Sliding Window**
    
    수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답(ACK) 없이 패킷을 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어 기법이다.
    
    최초의 **윈도우 크기**는 호스트들의 '3 way handshaking'을 통해 전달한 수신 측 윈도우 크기로 설정되며, 이후 **수신 측의 버퍼에 남아있는 공간에 따라 변한다**. 윈도우 크기는 수신 측에서 송신 측으로 확인 응답(ACK)을 보낼 때 TCP 헤더(window size)에 담아서 보낸다. 즉, 윈도우는 (데이터를 받을 수 있는) 메모리 버퍼의 일정 영역이라고 생각하면 된다.
    
    TCP/IP를 사용하는 모든 호스트는 송신하기 위한 Window와 수신하기 위한 Window를 가지고 있다. 호스트는 실제 데이터를 보내기 전에 수신 호스트의 수신용 Window size에 자신의 송신 Window size를 맞춘다.
    
    **세부 과정**
    
    1. 송신 버퍼
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/32253047-65b3-4d67-b9c3-0ff238942ef0/Untitled.png)
        
        - 200 이전의 바이트는 이미 전송되었고, 확인응답을 받은 상태
        - 200 ~ 202 바이트는 전송되었으나 확인응답을 받지 못한 상태
        - 203 ~ 211 바이트는 아직 전송이 되지 않은 상태
    2. 수신 버퍼
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b421007e-0911-4b87-8447-caeebc25af56/Untitled.png)
        
        - 194 ~ 199 : 버퍼를 차지하고 있는 수신한 바이트들
    3. 송신 버퍼
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4687b908-c1dc-4a1a-b23b-9bc9d2bc180a/Untitled.png)
        
        - 송신 윈도우 크기를 수신 윈도우보다 작거나 같은 크기로 지정하면 원활한 흐름 제어가 가능하다. 이보다 더 많은 데이터를 (응답 받지 않고) 보내지는 않을 것이기 때문이다.
    4. 송신 윈도우 이동
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/28081098-1053-487e-bc7f-8d65bf7cc6e2/Untitled.png)
        
        송신 윈도우의 모습인데, **Before**은 수신측으로부터 확인 메세지(ACK)를 받기 전의 모습이고, **After**은 수신측으로부터 ‘확인메세지 203(다음 받을 바이트의 순서 번호)'를 받은 후의 모습이다.
        
        수신측에서 다음 받을 바이트의 순서 번호를 담아 확인 메세지를 전송해오면, 송신측은 그 순서 번호에 해당하는 바이트(ex. 203)로 윈도우를 이동하여 이 과정을 반복한다. (확인 메세지와 함께 수신측 window size가 전달되므로 송신 윈도우도 그 크기에 맞춘다.)
        
        **슬라이딩 윈도우 작동 과정 예시**
        
        이 그림을 **대충보면** Stop and Wait랑 비슷하다고 생각할 수 있는데, 수신측(Server)의 수신 윈도우의 크기를 송신측에 전달하여 알림으로써 패킷(데이터 단위)을 하나씩 전송하고 확인하는 stop and wait의 비효율성을 해소한 것을 볼 수 있다. (나처럼 대충보지 않았다면 죄송!)
        
        ![스크린샷 2022-04-10 오후 1.40.11.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0f0dd08a-7bb9-4cbe-8199-d27b1d915663/스크린샷_2022-04-10_오후_1.40.11.png)
        

출처

- [https://gyoogle.dev/blog/computer-science/network/흐름제어 & 혼잡제어.html](https://gyoogle.dev/blog/computer-science/network/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%20&%20%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4.html)
- [https://steady-coding.tistory.com/507](https://steady-coding.tistory.com/507)
- [https://m.blog.naver.com/gaegurijump/110188012832](https://m.blog.naver.com/gaegurijump/110188012832)

---

## ****혼잡제어 (Congestion Control)****

송신측에서 네트워크로 들어가는 데이터의 양을 조절하여 네트워크가 혼잡해지지 않게 조절하는 방법이다.

흐름 제어가 송신측과 수신측 즉 end to end 간의 속도 차이를 해결하기 위한 기법이었다면, 혼잡 제어는 송신측과 네트워크간의 속도 차이를 해결하기 위한 기법이다.

**혼잡 상황**

송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다. 네트워크의 한 라우터에 데이터가 몰릴 경우, 자신에게 온 데이터를 정해진 시간 내에 모두 처리할 수 없게 된다. 이때 송신측(호스트)은 정해진 시간 안에 패킷이 처리됐다는 확인을 받지 못하면 또 다시 재전송하게되고 결국 네트워크에 더 많은 패킷이 전송되어 혼잡을 가중시킨다. 이러한 상황에서 오버플로우나 데이터 손실이 발생한다.

이렇듯 네트워크 내에 패킷의 수가 과도하게 증가하는 현상을 혼잡이라 하며, 혼잡 현상을 방지하거나 제거하는 기능을 **혼잡제어**라고 한다.

TMI : TCP의 혼잡제어는 1980년대 반제이콥슨이 도입함

**혼잡 제어 기법**

- ****AIMD(Additive Increase / Multiplicative Decrease)****
    
    번역하면 합 증가/곱 감소 방식으로, 전송하는 패킷의 수를 선형적으로(합하며) 증가시키고, 혼잡이 감지되면 곱하며 감소시키는 방식이다.
    
    **동작 방식**
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a958cb80-d4de-467b-a04f-1c120d3cf680/Untitled.png)
    
    - 처음에는 패킷을 **하나씩 보내고** 이것이 문제없이 도착했다는 **확인**을 하면 송신측 **window 크기**(단위 시간 내에 보내는 패킷의 수)를 **1씩 증가**시켜가며 전송한다.
    - 패킷 전송에 실패하거나 정해진 시간을 넘어도 확인 메세지를 받지 못하면 혼잡 상황으로 인지하고 윈도우 크기를 **절반으로 줄인다**.
    
    AIMD 방식은 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만, 시간이 흐르면 **평형상태로 수렴**하게 된다.
    
    - 어떻게 평형상태가 되는지
        
        먼저 네트워크에 참여해서 window크기를 늘리면서 데이터를 전송하고 있는 호스트보다 나중에 진입하여 window크기 1부터 1씩 증가시키는 호스트가 불리하지만, 시간이 지나면서 네트워크가 혼잡해지면, 먼저 들어온 호스트도 윈도우 크기를 절반으로 줄인다. 이때 남은 대역폭을 활용하여 나중에 들어온 호스트가 window 크기를 늘릴 수 있다. 따라서 시간이 흐르면 호스트별 대역폭 사용량(?)이 평형상태가 되는 것이다.
        
    
    **한계 및 문제점**
    
    윈도우 크기를 너무 조금씩(+1) 늘리기 때문에 초반에 네트워크의 모든 대역을 활용하여 더 빠른 속도로 통신하기까지 시간이 오래 걸린다.
    
    네트워크가 혼잡해지고 나서 이 혼잡 상황을 호스트가 인지하는 시점은 호스트가 정해둔 시간이 지나도 ACK 패킷을 받지 못했을 때(타임아웃)이다. 따라서 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다. (미리 감지하는 혼잡제어 기법이 어딨어..;) 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이다.
    
- ****Slow Start (느린 시작)****
    
    Slow Start 방식은 AIMD 방식이 처음에 전송 속도를 올리는데 시간이 오래걸리는 단점을 보완하는 방법이다.
    
    **동작 방법**
    
    - AIMD와 마찬가지로 패킷을 **하나씩** 보내면서 시작하고, 패킷이 문제없이 도착하면 **각 패킷의 확인메세지(ACK) 패킷마다** **윈도우 크기를 1씩** 늘려준다. 한 주기가 지나면(윈도우 크기만큼의 패킷들을 전송하면) 윈도우 크기가 이전의 **2배**가 된다. 따라서 전송속도는 AIMD에 반해 지수 함수 꼴로 증가한다.
    - slow start에서는 **임계값**(slow start threshold = sstresh)을 사용한다. 임계값까지 윈도우 크기를 늘리면 그 **이후부터**는 윈도우 크기를 2배가 아니라 **1씩 증가**시킨다.
    - 대신에 혼잡 현상이 발생하면 **윈도우 크기를 1로 떨어뜨리게** 된다.
    - 처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만, 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있다.
    - 그러므로 **임계값**을 **혼잡 현상이 발생했던 window size의 절반으로 정하고,** 임계값 이전까지는 **지수 함수 꼴로 윈도우 크기를 증가**시키고 **임계값 이후부터는 완만하게 1씩 증가**시킨다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/51d924c9-ec7a-483d-881b-7ac4bdaba162/Untitled.png)
    
    - TMI 1 이름이 느린 시작인 것에 대한 의문
        
        AIMD 보다 전송속도를 빠르게 높이는 것인데 왜 느린 시작이냐면, 느린 시작이 고안된 당시 TCP 전송 방식은 최대한 보낼 수 있을 만큼 보내고 시작하는 것이었기 때문이다. 당시 기존 방법보다 느려서 느린 시작
        
    
    **한계**
    
    이 방법도 AIMD 방법과 마찬가지로 타임아웃될 때까지 기다려야 혼잡상황을 인지한다.
    
- ****Fast Retransmit (빠른 재전송)****
    
    네트워크가 혼잡하면 패킷을 받는 수신자에게 세그먼트로 분할된 내용들이 순서대로 도착하지 않는 경우가 생길 수 있다.
    
    **동작 방식**
    
    - 수신측에서는 순서대로 잘 도착한 마지막 패킷의 **다음 순번**을 ACK 패킷에 실어서 보낸다. 받아야 하는 순번의 패킷이 아니라 다음 패킷이 도착한 경우에도, 먼저 받아야하는 순번의 패킷이 도착할 때 까지는 ACK 패킷을 보낼 때마다 먼저 받을 패킷의 순번을 담아서 전송한다.
    - 중간에 손실이 발생하면 수신측에서 같은 패킷을 요구하는 ACK 패킷을 반복적으로 보내게 된다. 이때 송신측에서는 순번이 중복된 ACK 패킷을 여러개 받게 되는데, 중복된 순번의 ACK 패킷을 3개 받으면 문제가 되는 순번의 패킷을 재전송한다.
    - 이때 약간 혼잡한 상황이 일어난 것이므로 혼잡을 감지하고 window size를 줄인다. (이거는 혼잡 상황을 미리 인지한 것?)
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/de02197d-83e8-4ce5-9aee-dc193113361f/Untitled.png)
    
    빠른 재전송은 TCP의 혼잡 조절에 추가된 정책이다. 
    
    **장점**
    
    송신 측은 자신이 설정한 타임아웃 시간이 지나지 않았어도 바로 해당 패킷을 재전송할 수 있기 때문에 보다 빠른 전송률을 유지할 수 있다.
    
- ****Fast Recovery (빠른 회복)****
    - 어떤 방식으로 시작했든, **혼잡한 상태**가 되면 window size를 1로 줄이지 않고 **반으로 줄이고 선형 증가**시키는 방법이다.
    - 이 정책을 적용하면 **혼잡 상황을 한번 겪고 나서부터**는 **순수한 AIMD 방식**으로 동작하게 된다.
    

### TCP 혼잡 제어 정책

위의 혼잡 제어 기법을 조합하여 적용한 혼잡 제어 정책들이 있다. 이론적으로 대표적인 혼잡 제어 정책인 Tahoe와 Reno에 대한 설명이다. 

- **TCP Tahoe**
    
    `TCP Tahoe`는 처음에는 `Slow Start`를 사용하다가 임계점에 도달하면 `AIMD` 방식을 사용한다. 그러다가 `3 ACK Duplicated` 또는 `타임아웃`이 발생하면 혼잡이라고 판단하여 **임계점**은 **혼잡이 발생한 윈도우 크기의 절반**으로, **윈도우 크기는 1로** 줄인다.
    
    **동작 방식**
    
    - 윈도우 크기를 **지수함수 꼴**로 증가시킨다. (Slow Start)
    - **임계점**에 도달하면 **선형적**으로 윈도우 크기를 증가시킨다. (AIMD)
    - 3개의 중복된 ACK 패킷을 전달받거나 타임아웃이 발생하면, 임계점을 혼잡이 발생한 윈도우 크기의 `절반`으로, 윈도우 크기는 `1`로 줄인다. (Slow Start)
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a3f54267-4ef9-49bf-94fe-0f81ef17d2d0/Untitled.png)
    
    위 그래프에서 청록색 선은 송신 측의 혼잡 윈도우 크기를, 굵은 검정선은 ssthresh 값을 보여주고 있다.
    
    **단점**
    
    이 방식은 혼잡 이후 Slow Start 구간에서 윈도우 크기를 키울 때 너무 오래걸린다는 단점이 있다. 1부터 키워나가야 하기 때문이다.
    
- **TCP Reno**
    
    이 방식은 느린 시작, 빠른 재전송, 빠른 회복 셋을 모두 구현하며, [마이크로소프트 윈도우](https://ko.wikipedia.org/wiki/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%86%8C%ED%94%84%ED%8A%B8_%EC%9C%88%EB%8F%84%EC%9A%B0) 운영체제도 이 방식으로 동작한다.
    
    `TCP Tahoe`와 마찬가지로 Slow Start로 시작하여 임계점을 넘어가면 `AIMD` 방식으로 변경한다.
    
    `TCP Tahoe`와의 차이점은 바로 `3 ACK Duplicaed`와 `타임아웃`을 구분한다는 점이다. 
    
    `TCP Reno`는 `3 ACK Duplicated`가 발생하면 **빠른회복** 방식을 사용한다. (→ AIMD)
    
    `타임아웃` 이 발생하면 **Slow Start** 방식을 사용한다.
    
    **동작 방식**
    
    - 윈도우 크기를 **지수함수 꼴**로 증가시킨다. (Slow Start)
    - **임계점**을 넘어가면 윈도우 크기를 **선형적으로** 증가시킨다. (Slow Start)
    - **3개의 중복 ACK**을 받으면, **임계점**을 해당 시점의 윈도우 크기의 **절반**으로 변경하고, **윈도우 크기도 절반** 크기로 줄인다. 이후부터는 어차피 임계값 이후 이므로 **선형적으로 증가**시킨다. (빠른회복)
    - **타임아웃**이 발생하면, **윈도우 크기**를 **1**로 줄이고 **Slow Start** 방식과 동일하게 동작한다. (Slow Start)
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/72918a70-81b9-4b9c-9fee-bf8caedd3d4b/Untitled.png)
    
- **그 외**
    
    최근에 많이 사용하는 혼잡 제어 기법이라고 한다. 큰틀에서는 위의 방식과 유사하다.
    
    - CUBIC
    - RED
    - Elastic TCP

출처

[https://gyoogle.dev/blog/computer-science/network/흐름제어 & 혼잡제어.html](https://gyoogle.dev/blog/computer-science/network/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%20&%20%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4.html)

[https://ko.wikipedia.org/wiki/혼잡_제어](https://ko.wikipedia.org/wiki/%ED%98%BC%EC%9E%A1_%EC%A0%9C%EC%96%B4)

[https://velog.io/@mu1616/TCPIP-혼잡-제어](https://velog.io/@mu1616/TCPIP-%ED%98%BC%EC%9E%A1-%EC%A0%9C%EC%96%B4)

[https://evan-moon.github.io/2019/11/26/tcp-congestion-control/#tcp-tahoe](https://evan-moon.github.io/2019/11/26/tcp-congestion-control/#tcp-tahoe)
