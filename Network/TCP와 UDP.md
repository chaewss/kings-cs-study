# TCP와 UDP
## TCP
- TCP(: Transmission Control Protocol)는 데이터를 보내기 위해 전송 계층에서 사용하는 프로토콜이다.  
- 신뢰할 수 없는 환경에서도 통신을 보장하기 위해 세션을 안전하게 연결하고 데이터를 분할한 패킷의 순서를 잘 쪼개고 조립하는 역할을 한다.  
- 패킷의 순서를 잘 쪼개고 조립하기 위해 시퀀스 번호로 패킷에 순서를 부여하고 패킷을 일방적으로 보내는 것이 아니라 ACK 번호로 응답 번호를 부여해 상대방이 잘 받았는지 확인한다. 또 안전한 연결을 보장하기 위해 수신자가 받을 수 있는 전송 크기(Window Size)까지 고려해 통신을 한다.
- TCP는 웹 브라우저들이 월드 와이드 웹에서 서버에 연결할 때 사용되며, 이메일 전송이나 파일 전송 등에 사용된다.  
<br><br>

- TCP 세그먼트는 `헤더`와 `데이터` 두 섹션으로 구성된다.  
  - TCP 헤더는 10개의 필수 필드 및 옵션 확장 필드(표 하단의 빨간색 부분)들을 포함한다.
  - 헤더 뒤 데이터 섹션은 애플리케이션의 `페이로드 데이터`이다. 데이터 섹션의 길이는 IP 헤더에 의해 결정된다.

### TCP 헤더 구조
![TCP-header](https://evan-moon.github.io/static/ac69210c44cd473bcb737665d590b124/c7bb6/tcp-header.png)  
- `Source Port` / `Destination Port`  
• Source Port는 메시지를 보내는 측에서 통신을 위해 사용하는 Port 번호   
• Destination Port는 목적지, 즉 메시지를 받는 측의 통신 Port 번호 
- `Sequence Number`  
• TCP 세그먼트 안의 데이터의 송신 바이트 흐름의 위치를 가리킨다. 다른 호스트로 전달되는 세그먼트는 여러 개의 서로 다른 경로를 거치며 세그먼트의 순서가 뒤바뀔 수 있다. 이를 수신 측에서 재조립하기 위해 사용되는 Number이다.  
• SYN Flag가 1인 경우, 이것은 초기 Sequence Number가 되며 실제 데이터의 최초 바이트 값과 그에 상응하는 ACK 번호는 이 값에 1을 더한 값이 된다. SYN Flag가 0인 경우, 이것은 현재 세션의 이 세그먼트 데이터의 최초 바이트 값의 누적 Sequence Number 이다.
- `Acknowledgment Number`  
• 수신자의 입장에서 송신자로부터 앞으로 받아야 할 다음 데이터의 Sequence Number. 이는 모든 선행하는 바이트들(존재할 경우)의 수신에 대한 확인응답이 된다. 한 쪽이 보낸 최초의 ACK는 반대 쪽의 초기 Sequence Number 자체에 대한 확인응답이 되며, 데이터에 대한 응답은 포함되지 않는다.  
- `Data Offset`  
• 32-bit(4-byte) 워드 단위로 나타낸 TCP 헤더 크기 값.  
- `Reserved`  
• 미래에 사용하기 위해 남겨둔 예비 필드이며 0으로 채워져야 한다.  
- `Flags` 
• Segment의 용도와 내용을 결정하기 위해서 사용  
- `Window Size` 
• 해당 세그먼트의 송신 측이 현재 수신하고자 하는 수신 윈도의 크기를 나타내며 기본 단위는 바이트 이다.  
- `Checksum`  
• 헤더 및 데이터의 에러 확인을 위해 사용  
- `Urgent Pointer`  
• URG Flag가 설정된 경우 긴급 메시지를 보낸다. Urgent Pointer는 일반 데이터 내에서 긴급 데이터가 시작되는 위치 정보를 가지고 있다.  
- `Options`  
• TCP 헤더의 정보를 좀 더 확장시키고자 할 때 사용  
- `Padding` 
• TCP 헤더의 종료 지점과 데이터의 시작 지점을 32비트 단위 길이에 맞추기 위해 사용되며 패딩의 값은 0이다. 

### TCP 동작
① `3-way handshake`: 연결 생성 (Connection establishment)   
② 자료 전송 (Data transfer)  
③ `4-way handshake`: 연결 종료 (Connection termination)  
TCP는 신뢰성 있는 연결이 생성되어야 하며, 그 후 자료를 전송하고, 마지막으로 연결을 종료하면서 할당된 자원을 반납한다.


---

## UDP
- TCP의 안정성을 필요로 하지 않는 애플리케이션의 경우 일반적으로 TCP 대신 UDP(: User Datagram Protocol)을 사용한다.
- UDP는 TCP와는 달리 데이터 전송을 보장하지 않고 전달 확인 및 순차 보장 기능이 없는 대신 오버헤드가 작고 지연시간이 짧다. 데이터 통신은 신뢰성이 핵심이나 UDP는 신뢰성을 보장하지 않기 때문에 일부 데이터가 유실되더라도 시간에 맞추어 계속 전송하는 것이 중요한 서비스 등 제한된 용도로만 사용된다.

### UDP 헤더 구조
![UDP-header](https://t1.daumcdn.net/cfile/tistory/99B12B385BD6DC0F03?download)
- `Source Port` / `Destination Port`  
• Source Port는 메시지를 보내는 측에서 통신을 위해 사용하는 Port 번호  
• Destination Port는 목적지, 즉 메시지를 받는 측의 통신 Port 번호  
- `Total Length`  
• 헤더와 데이터를 합한 사용자 데이터그램의 전체 길이를 정의  
- `Checksum`  
• 헤더와 데이터를 모두 포함한 사용자 데이터그램 전체에 대해 오류를 탐지하기 위해 사용  

### UDP 동작
- 비연결형 서비스
  - UDP에 의해 보내어진 각 사용자 데이터그램은 서로 독립적이다. 동일한 발신지 프로그램으로부터 동일한 목적지 프로그램으로 전송되더라도 서로 다른 데이터그램들 사이에는 아무런 연관 관계가 없다. 사용자 데이터그램에는 번호가 붙지 않으며 연결 설정, 종료 과정이 없다.
- 흐름제어와 오류제어
  - 흐름제어도 없고 윈도우 메커니즘도 없으므로 수신 측에서 들어오는 메시지로 인해 오버플로우가 발생할 수 있으며 검사합을 제외하고는 오류제어 메커니즘이 없다. 이것은 메시지가 없어지거나 중복되었는지 송신자가 알 수 없다는 것이다. 수신자가 Checksum을 사용하여 오류가 있음을 발견하면 사용자 데이터그램은 폐기된다.
- 캡슐화와 역 캡슐화
  - 캡슐화  
→ 프로세스가 UDP를 통하여 보낼 메시지가 있을 때 UDP로 `메시지`와 한 쌍의 `소켓 주소`, `데이터의 길이`를 보낸다. UDP는 데이터를 받은 후 UDP 헤더를 추가하고 소켓 주소들과 함께 사용자 데이터그램을 IP로 보낸다. IP는 자신의 헤더를 추가하는데 이 헤더에서 Protocol Field의 값을 17로 설정하여 데이터가 UDP로부터 왔음을 알린다. 이 후 데이터 링크 계층, 물리 계층을 거쳐 원격 시스템으로 보낸다. 이러한 일련의 과정을 ‘캡슐화’라 한다.
  - 역 캡슐화  
→ 메시지가 목적지 호스트에 도착하면 물리 계층, 데이터 링크 계층은 헤더와 트레일러 들을 없앤 후 데이터를 IP로 보낸다. IP 소프트웨어는 IP단계의 검사를 수행하고 만약 오류가 없으면 헤더를 없앤 후 송신자/수신자 IP주소와 함께 사용자 데이터그램을 UDP로 보낸다. UDP는 검사합을 사용하여 전체 사용자 데이터그램을 검사하여 오류가 없으면 헤더를 없앤 후 송신자 소켓 주소와 함께 응용 데이터를 프로세스에 전달한다. 수신된 메시지에 대해 응답을 보낼 필요가 있을 경우에 대비하여 송신자 소켓 주소가 프로세스에 전달된다. 이 과정을 ‘역 캡슐화’라 한다.
- 다중화와 역 다중화
  - 다중화  
→ 송신자 측에서 사용자 데이터 그램을 보내고자 하는 프로세스가 여러 개 있더라도 UDP는 하나만 있다. 이것은 N:1 관계이다. 포트 번호가 서로 다른 프로세스들로부터 메시지를 수신하면, UDP에는 헤더를 추가한 후 IP로 사용자 데이터 그램을 보낸다.
  - 역 다중화  
→ 수신자 측에서 사용자 데이터 그램을 받고자 하는 프로세스가 여러 개 있더라도 UDP는 하나만 있다. 이것은 1:N 관계이다. UDP는 사용자 데이터그램을 IP로부터 받아 오류를 점검하고 헤더를 없앤 후 포트 번호에 의거하여 각 메시지를 적절한 프로세스로 보낸다.
- 큐잉  
![UDP-Queueing](https://mblogthumb-phinf.pstatic.net/20110809_224/twers_1312850272650ngvXp_PNG/%B4%D9%C1%DF%C8%AD%BF%CD_%BF%AA%B4%D9%C1%DF%C8%AD.png?type=w2)  

    **클라이언트 프로세스**

       ① UDP에서는 포트에 큐(Queue)가 연동

       ② 프로세스가 시작되면, 운영체제에게 포트번호 요청

       ③ 큐는 포트번호로 식별

       ④ 프로세스 종료 시 큐도 제거

       ⑤ 출력큐가 가득 차서, 큐에 넣을 수 없을 때 운영체제는 프로세스에게 대기 요청

          * 소켓 프로그램에서 sendto()가 blocking 됨

       ⑥ 메시지가 클라이언트에 도착하면 UDP는 지정된 포트번호에 대한 입력큐 존재 여부 확인. 입력큐가 있으면 큐에 삽입

       ⑦ 입력큐가 없으면, 데이터그램 폐기한 후 ICMP에 "도달불가" 메시지 전달 요청

    **서버 프로세스**

       ① 운영체제에 따라 큐 생성방법이 다름

       ② 서버 프로세스가 수행될 때, 잘 알려진 포트에 대하여 입력 큐와 출력 큐 생성

       ③ 서버에 메시지가 오면, 사용자 데이터그램의 목적지 포트번호로 지정된 포트에 입력 큐 존재 여부를 확인.

           입력큐가 있으면 큐에 삽입

       ④ 입력큐가 없으면, 데이터그램 폐기한 후 ICMP에 "도달불가" 메시지 전달 요청

       ⑤ 입력큐에 오버플로우(Overflow)가 발생해도 데이터그램 폐기 후, ICMP에 "도달불가" 메시지 전달 요청

       ⑥ 서버에 클라이언트에 응답하기를 원하는 경우, 수신 데이터그램에 있는 발신지 포트번호를 이용해 생성된 데이터그램을 출력큐에 삽입

       ⑦ 출력큐가 가득 차서, 사용자 데이터그램을 넣지 못하면, 운영체제는 프로세스에게 대기 요청
<br><br>
**출처**  
- [SongLee, 개발, IT, 맛집, 여행, Etc..](https://joycecoder.tistory.com/13)
- [UDP (User Datagram Protocol)](https://m.blog.naver.com/twers/50117815403)