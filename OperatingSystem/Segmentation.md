# 세그먼테이션(Segmentation)

세그먼테이션은 페이징기법과 같이 프로세스를 메모리에 저장할 때 하나의 프로세스를 여러개의 segment(frame)로 나누어 저장하는 방법이다.   

페이징은 프로세스를 균일한 크기의 페이지로 잘라서 저장하는 방법이고, 세그테이션은 논리적 단위(즉 내용별)로 나누어 저장하는 방법이다.   
예를들면 메인 프로그램, precedure, function, method, object, local variables, global variables, common block, symbol table, arrays 등으로 나눌 수 있다.

![image](https://user-images.githubusercontent.com/41771874/165046628-ffc978e6-e713-42cc-b6dd-14c9cffffa60.png)

위 그림에서 왼쪽에 있는 logical address space가 하나의 프로그램을 내용별로 묶인 세그먼트들로 나누어 (논리적으로) 표현한 모습이다.

오른쪽에는 논리 주소를 물리 주소로 변환하기 위해 필요한 segment table과 실제 segment들이 메모리에 저장되어 있는 모습을 나타낸 physical memory 그림이다.

## 세그먼트 테이블

![image](https://user-images.githubusercontent.com/41771874/165046662-b0e55dd1-d35c-4575-9838-83be8c632ed0.png)

세그테이션을 위해서는 세그먼트 테이블이 필요하다.   
논리주소를 물리주소(실제 메모리에 접근할 때 사용하는 주소)로 변환하기 위해 segment table을 사용한다.

세그먼트 테이블은 메모리 내에 **세그먼트의 시작주소(Base), 세그먼트 크기(Limit)**를 엔트리로 갖는다.

즉, 위 그림에서 세그먼트 0은 메모리의 1400번째에 위치하며, 그 크기는 1400이다. 즉 메모리의 1400~2800까지 segment 0이 할당되어 있는 것이다.

## 논리 주소 → 물리 주소

세그먼트의 특정 주소에 접근하기 위해서는 **논리주소**를 사용하는데, 논리주소는 **<세그먼트 번호, offset(해당 세그먼트 내의 특정 위치)>** 로 이루어진다.   

따라서 접근할 때 예를들어 논리주소가 <2, 100>이라면   
2번 세그먼트가 시작하는 위치(Base)+offset 값이 논리주소가 실제로 가리키는 물리적 주소가 되는 것이다.

### **예시**

**논리 주소 : <3, 123>** 

**3** : 세그먼트 번호   
**123** : 세그먼트 내의 접근하고자 하는 위치(offset)    
바로 위의 segment table 그림을 사용한다고 하면,   
Segment **3**의 **Base**가 **4800**이고, offset이 **123**이므로   
실제 메모리 상 물리주소는 **4800** + **123** = **4923**   

**물리 주소 : 4923**

## 세그먼테이션에서 보호(Protection)와 공유(Sharing)

**페이징**에서 보호와 공유가 상대적으로 어려웠다.   
페이징은 내용과 상관없이 일정한 크기별로 프로세스를 분할하는 것이기 때문에, **접근권한(r,w,rw)**이 서로 다른 데이터들이 하나의 페이지로 묶이는 경우가 있을 수 있기 때문이다.

하지만 **세그테이션**에서는 내용별로 묶이기 때문에 **하나의 세그멘트**에 포함된 내용이 **동일한 접근권한**을 갖는다면 데이터의 보호가 훨씬 수월하다.   
세그먼트를 **공유**할 때에도 마찬가지로, 페이지는 하나의 페이지에 공유하고 싶은 데이터와 공유하고 싶지 않은 데이터가 함께 존재할 수 있지만, 세그먼트는 그렇지 않다.

## 세그먼테이션에서 재배치(Relocation)

세그먼테이션을 사용하면서 메모리에 세그먼트를 재배치 하려면, 메모리에서 세그먼트를 재배치한 뒤에 segment table에서 base의 값을 변경해주면 된다.   
따라서 dynamic relocation이 가능하다.

## 세그먼테이션의 단점(외부 단편화)

세그먼테이션은 메모리에 세그먼트를 로드할 때 first-fit과 best-fit 방식을 사용한다.   
first-fit은 크기가 맞는 비어있는 공간 중 가장 첫번째 공간에 세그먼트를 할당하는 방식이고,   
best-fit은 크기가 큰 공간 중에서 세그먼트 크기와 가장 차이가 적은 공간에 세그먼트를 할당하는 방식이다.   

이처럼 세그먼테이션은 서로 다른 크기의 세그먼트들을 메모리의 곳곳에 저장하면, 군데군데 빈 공간이 발생한다. 이를 hole이라고 한다.    
크기가 일정하지 않은 hole이 메모리 상에 발생하게 되고 따라서 **외부 단편화**가 발생하여 메모리의 낭비가 발생한다.

**외부 단편화**는 프로세스가 메모리에 로드되고 제거되는 과정을 거치면서, 메모리의 빈 공간이 더 작은 공간으로 쪼개지는 것을 의미한다.   
빈 공간들을 합치면 요구되는 공간이 있지만, 연속된 공간이 아니어서 할당할 수 없는 상태이다.

이 단점(외부 단편화)을 보완하기 위한 기법이 바로 **세그먼테이션 with 페이징**이다.

# 세그먼테이션-페이징 혼용 기법(Segmentationn with Paging)

세그먼테이션에서 발생하는 외부 단편화 문제는 세그먼트 마다 크기가 다르기 때문에 발생하는 것이다.    
이를 해결하기 위해 하나의 세그먼트를 여러개의 (일정한 크기의)페이지로 나누어 메모리에 저장하는 것이 이 방법이다.    

이 방법을 사용하면 세그먼테이션의 장점과 더불어   
메모리에는 일정한 크기의 페이지들이 저장되므로 외부단편화가 발생할 가능성이 줄어든다.

<center><img src="https://user-images.githubusercontent.com/41771874/165046716-2e7d911b-a1b1-4a96-a6c9-72874f2a189e.png" width="500"></center>

세그먼트가 여러개의 페이지로 나뉘어 저장되는 모습

## 작동원리

이 방법에서는 프로세스를 여러개의 segment로 나누고, 이 segment를 여러개의 page로 나누는 것이다.

따라서 프로세스마다 하나의 **segment table**이 필요하다.   
그리고 세그먼트마다 하나의 **page table**이 필요하다.   

이 테이블은 모두 메인 메모리에 위치한다.

**segement table**은 각 세그먼트마다 **페이지 테이블의 시작 주소(Base)**와 **해당 페이지 테이블의 크기(Limit)**를 갖는다.   
**page table**은 하나의 세그먼트에 대한 page table이다. 따라서 **각 페이지의 메모리상 위치(frame number)**를 갖는다.

## 논리주소 → 물리주소

주소 변환을 위해서 두 개의 테이블이 사용된다.

논리주소가 2, 1 234 이면

세그먼트 번호 : 2
페이지 번호 : 1
offset(페이지 내의 위치) : 234
인 것이다.

1. 세그먼트 테이블에서 세그먼트 번호가 2인 행을 찾아, 페이지 테이블의 시작 주소를 얻는다.
2. 해당 페이지 테이블에서 페이지 번호가 1인 행을 찾아 페이지(1)의 실제 물리 주소를 얻는다.
3. 페이지의 물리 주소 + offset(234)가 실제 메모리 내의 주소이다.

![image](https://user-images.githubusercontent.com/41771874/165046848-29b47fc4-13a9-47cc-9f72-522a88527ddc.png)

## 단점

- 메모리에 3번 접근해야함(segmentTable, pageTable, physical address)
- 페이징 기법이 갖는 내부 단편화 문제는 발생할 수 있음
