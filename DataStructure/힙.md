# 힙
## '우선순위 큐(Priority Queue)'란?
- 우선순위 개념 + 큐
- 이용 사례
  - 시뮬레이션 시스템
  - 네트워크 트래픽 제어
  - OS 작업 스케쥴링
  - 수치 해석적인 계산
- 배열, 연결리스트, **힙**으로 구현 가능하며, 힙 구현이 가장 효율적

|자료 구조|삭제되는 요소|
|------|---|
|스택(Stack)|가장 최근에 들어온 데이터|
|큐(Queue)|가장 먼저 들어온 데이터|
|우선순위 큐(Priority Queue)|가장 우선순위가 높은 데이터|

## '힙(heap)'이란?
- **완전 이진 트리의 일종**으로 우선순위 큐를 위하여 만들어진 자료구조
- 여러 개의 값들 중에서 최댓값이나 최솟값을 빠르게 찾아내도록 만들어진 자료구조
- 일종의 **반정렬 상태(느슨한 정렬 상태)** 유지 
  - 큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다는 정도
  - 간단히 말하면 부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은) 이진 트리
- 힙 트리에서는 중복된 값 허용 (이진 탐색 트리에서는 중복된 값을 허용하지 않는다.)

## 힙(heap) 종류
![heap](https://gmlwjd9405.github.io/images/data-structure-heap/types-of-heap.png)
- 최대 힙(max heap)
  - 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리
  - key(부모 노드) >= key(자식 노드)
- 최소 힙(min heap)
  - 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리
  - key(부모 노드) <= key(자식 노드)

## 힙(heap) 구현
- 힙을 저장하는 표준적인 자료구조는 **배열**
- 구현을 쉽게 하기 위해 배열의 첫 번째 인덱스인 0은 사용 X
- 특정 위치의 노드 번호는 새로운 노드가 추가되어도 변하지 않음
  - 예를 들어 루트 노드의 오른쪽 노드의 번호는 항상 3이다.
- 힙에서의 부모 노드와 자식 노드의 관계 
  - 왼쪽 자식의 인덱스 = (부모의 인덱스) * 2
  - 오른쪽 자식의 인덱스 = (부모의 인덱스) * 2 + 1
  - 부모의 인덱스 = (자식의 인덱스) / 2
![heap](https://gmlwjd9405.github.io/images/data-structure-heap/heap-index-parent-child.png)

### 삽입 연산
![insert](https://gmlwjd9405.github.io/images/data-structure-heap/maxheap-insertion.png)  
1. 힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 이어서 삽입
2. 새로운 노드를 부모 노드들과 교환해서 힙의 성질을 만족시킴

### 삭제 연산
![delete](https://gmlwjd9405.github.io/images/data-structure-heap/maxheap-delete.png)  
1. 최대 힙에서 최댓값은 루트 노드이므로 루트 노드 삭제됨
2. 삭제된 루트 노드에 힙의 마지막 노드를 가져옴
3. 힙 재구성
<br><br>
**출처**  
- [힙(heap)이란](https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html)