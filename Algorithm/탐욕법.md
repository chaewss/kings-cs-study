# 탐욕 알고리즘
탐욕 알고리즘은 **결정을 해야 할 때마다 미래는 전혀 고려하지 않고 그 순간에 가장 좋다고 생각되는 것을 해답으로 선택**함으로써 최종적인 해답에 도달  
그 순간의 선택은 그 당시(local)에는 최적이나 최적이라고 생각했던 해답들을 모아 최종적인(global) 해답을 만들었다고 해서, 그 해답이 궁극적으로 최적이라는 보장이 없음.  
따라서 탐욕 알고리즘은 항상 찾은 답이 최선의 해답인지 추가 검증 필요

## 탐욕 알고리즘 설계 절차
1. 선정 과정(selection procedure)  
    현재 상태에서 가장 좋으리라고 생각되는 해답을 찾아 해답 모음에 포함시킴
2. 적정성 점검(feasibility check)  
    새로 얻은 해답 모음이 적절한지 결정
3. 해답 점검(solution check)  
    새로 얻은 해답 모음이 최적의 해인지 결정

## 탐욕 알고리즘의 예
1. 거스름돈 문제  
    현재 우리나라에 유통되는 동전만을 가지고 탐욕 알고리즘을 적용해 거스름돈을 줄 경우, 항상 동전의 개수는 최소가 되어 최적(optimal)이다. 그러나 만약 12원짜리 동전을 새로 발행할 경우 항상 동전의 개수가 최소가 된다는 보장 X.
2. 최소비용 신장 트리(MST: Minimum Spanning Tree)
    ex) 도로 건설, 통신, 배관
    1) Prim 알고리즘
       1. **선정 절차/적정성 점검**: V- Y에 속한 정점 중, Y에 가장 가까운 정점 하나를 선정
       2. 선정한 정점 Y에 추가
       3. Y로 이어지는 이음선을 F에 추가
       4. **해답 점검**: Y = V가 되면, T = (V, F)가 최소비용신장트리 이다.
    ![Prim알고리즘](https://user-images.githubusercontent.com/60397314/169709731-33f3105c-760a-4004-88a4-c9bbc231c8cc.png)   
    * 이미 연결된 정점 사이의 이음선을 추가하면 사이클이 생성돼 최소가 될 수 없음  
    → 이음선 한쪽 끝은 Y에, 남은 한쪽 끝은 V - Y에 있는 이음선을 고름
    <br><br>
    2) Kruskal 알고리즘
       1. **선정 절차**: 최소의 가중치를 가진 이음선 선정
       2. **적정성 점검**: 만약 선정된 이음선이 두 개의 서로소인 정점을 잇는다면, 먼저 그 부분집합을 하나의 집합으로 합하고, 그 다음에 그 이음선을 F에 추가한다.
       3. **해답 점검**: 만약 모든 부분집합이 하나의 집합(모든 정점들이 connected 됐을 때)으로 합하여지면, 그 때 T = (V, F)가 최소비용신장트리이다.
    ![Kruskal알고리즘](https://user-images.githubusercontent.com/60397314/169709774-420d1621-5954-4bb6-8dc6-4a570c603217.png)   
    주어진 그래프가 sparse/dense 중 어떤 것인지에 따라 Prim/Kruskal 중 유리한 것이 달라진다.
3. Dijkstra 알고리즘(단일출발점 최단경로)
    ![Dijkstra알고리즘](https://user-images.githubusercontent.com/60397314/169709786-cf55965e-17ab-4286-9d56-01537d049203.png)   
4. 스케줄 짜기
5. Huffman code
6. 배낭 빈틈없이 채우기 문제(The Fractional Knapsack Problem)
<br><br>
**출처**  
- 김도형 교수님 알고리즘 교안